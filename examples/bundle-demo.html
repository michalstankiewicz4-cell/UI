<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>UI Bundle Demo - FAZA C1 Header Buttons!</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: 'Courier New'; }
        canvas { display: block; cursor: default; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script src="../dist/ui.js"></script>
    <script>
        console.log('=== FAZA C1: HEADER BUTTONS v2.0 - HUD MODE! ===');
        
        // ============================================
        //  PATCHES (same as before)
        // ============================================
        
        // PATCH 1: Button borders
        UI.BaseWindow.prototype.drawButton = function(ctx, STYLES, item, y) {
            ctx.fillStyle = 'rgba(0, 255, 136, 0.2)';
            ctx.fillRect(this.x + this.padding, y, this.width - this.padding * 2, 20);
            ctx.strokeStyle = STYLES.colors.panel;
            ctx.lineWidth = 2;
            ctx.strokeRect(this.x + this.padding, y, this.width - this.padding * 2, 20);
            ctx.fillStyle = STYLES.colors.panel;
            ctx.font = STYLES.fonts.mainBold;
            ctx.textAlign = 'center';
            ctx.fillText(item.label, this.x + this.width / 2, y + 14);
            ctx.textAlign = 'left';
        };
        
        // PATCH 2: handleClick
        UI.BaseWindow.prototype.handleClick = function(mouseX, mouseY) {
            if (!this.visible) return false;
            
            let y = this.y + this.headerHeight + this.padding - this.scrollOffset;
            
            for (let item of this.items) {
                if (item.type === 'button') {
                    const bx = this.x + this.padding;
                    const by = y;
                    const bw = this.width - this.padding * 2;
                    
                    if (mouseX >= bx && mouseX <= bx + bw && mouseY >= by && mouseY <= by + 20) {
                        item.callback();
                        return true;
                    }
                    y += 20 + this.itemSpacing;
                } else if (item.type === 'text') {
                    y += (item.lines || 1) * 14 + this.itemSpacing;
                } else if (item.type === 'section') {
                    y += 20 + this.itemSpacing;
                }
            }
            return false;
        };
        
        // PATCH 3: WindowManager.handleMouseDown
        // FIXED: Use startDrag() which has header button logic!
        UI.WindowManager.prototype.handleMouseDown = function(x, y) {
            this.mouseDownX = x;
            this.mouseDownY = y;
            
            for (let i = this.windows.length - 1; i >= 0; i--) {
                const win = this.windows[i];
                
                // Check if window was clicked
                if (win.visible && win.containsPoint(x, y)) {
                    this.bringToFront(win);
                    
                    // Try header first (includes buttons and dragging)
                    if (win.containsHeader(x, y)) {
                        const handled = win.startDrag(x, y);
                        
                        if (handled) {
                            // If dragging started, set activeWindow
                            if (win.isDragging) {
                                this.activeWindow = win;
                            }
                            return true;
                        }
                    } else {
                        // Content clicked - set activeWindow for click handling
                        this.activeWindow = win;
                        win.isDragging = false;
                        return true;
                    }
                }
            }
            return false;
        };
        
        // PATCH 4: EventRouter
        UI.EventRouter.prototype.handleMouseDown = function(e) {
            this.mouseDown = true;
            this.lastMouseX = e.clientX;
            this.lastMouseY = e.clientY;

            const taskbarY = this.canvas.height - 48;
            if (e.clientY >= taskbarY && this.taskbar) {
                const ctx = this.canvas.getContext('2d');
                if (this.taskbar.handleClick(e.clientX, e.clientY, ctx, this.windowManager)) {
                    e.preventDefault();
                    return;
                }
            }

            if (this.windowManager.handleMouseDown(e.clientX, e.clientY)) {
                e.preventDefault();
            }
        };
        
        UI.EventRouter.prototype.handleMouseUp = function(e) {
            if (this.windowManager && this.windowManager.activeWindow) {
                const win = this.windowManager.activeWindow;
                const dx = Math.abs((this.windowManager.mouseDownX || e.clientX) - e.clientX);
                const dy = Math.abs((this.windowManager.mouseDownY || e.clientY) - e.clientY);
                const dragged = win.isDragging && (dx > 3 || dy > 3);
                
                if (!dragged) {
                    win.handleClick(e.clientX, e.clientY);
                }
                
                win.isDragging = false;
                this.windowManager.activeWindow = null;
            }
            this.mouseDown = false;
        };
        
        UI.EventRouter.prototype.handleMouseMove = function(e) {
            if (this.windowManager && this.windowManager.activeWindow) {
                const win = this.windowManager.activeWindow;
                if (win.isDragging) {
                    win.x = e.clientX - win.dragOffsetX;
                    win.y = e.clientY - win.dragOffsetY;
                }
            }
        };
        
        console.log('âœ… Patches applied');
        
        // ============================================
        //  SETUP
        // ============================================
        
        const canvas = document.getElementById('canvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const ctx = canvas.getContext('2d');
        
        const windowManager = new UI.WindowManager();
        const taskbar = new UI.Taskbar();
        
        // Window 1: Welcome with header buttons demo
        const welcomeWindow = new UI.BaseWindow(50, 50, 'Welcome - FAZA C1!');
        welcomeWindow.width = 400;
        welcomeWindow.height = 280;
        welcomeWindow.addText('UI Bundle v2.0.0 - HUD!', '#00FF88');
        welcomeWindow.addText(' ');
        welcomeWindow.addText('NOWE: Eye = HUD mode!', '#00F5FF');
        welcomeWindow.addText('* X - Zamknij (usuwa z menu)', '#00FF88');
        welcomeWindow.addText('* _ - Minimalizuj (na taskbar)', '#00FF88');
        welcomeWindow.addText('* O - HUD mode (floating stats)', '#00FF88');
        welcomeWindow.addText(' ');
        welcomeWindow.addText('HUD mode:', '#00F5FF');
        welcomeWindow.addText('- Ukrywa header, border, ramke', '#00FF88');
        welcomeWindow.addText('- Zostawia tylko content', '#00FF88');
        welcomeWindow.addText('- Floating eye button przywraca', '#00FF88');
        welcomeWindow.addText(' ');
        
        let clickCount = 0;
        welcomeWindow.addButton('Test Button', () => {
            clickCount++;
            alert('Dziala! Kliknieto: ' + clickCount);
        });
        
        // NOWE: onClose callback - usuwa z windowManager I taskbar
        welcomeWindow.onClose = () => {
            console.log('Zamykam okno Welcome!');
            windowManager.remove(welcomeWindow);
            taskbar.removeWindowItem(welcomeWindow);
        };
        
        windowManager.add(welcomeWindow);
        taskbar.addSection('windows');
        taskbar.addWindowItem('Welcome', welcomeWindow);
        
        // Window 2: Info
        const infoWindow = new UI.BaseWindow(470, 50, 'Bundle Info');
        infoWindow.width = 300;
        infoWindow.height = 320;
        infoWindow.addSection('zawartosc');
        infoWindow.addText('* Styles.js', '#00FF88');
        infoWindow.addText('* TextCache.js', '#00FF88');
        infoWindow.addText('* BaseWindow.js (NEW!)', '#00FF88');
        infoWindow.addText('* WindowManager.js', '#00FF88');
        infoWindow.addText('* Taskbar.js', '#00FF88');
        infoWindow.addText('* EventRouter.js', '#00FF88');
        infoWindow.addText(' ');
        infoWindow.addSection('stats');
        infoWindow.addText('Total: ~1291 linii', '#00F5FF');
        infoWindow.addText('Bundle: ~50KB', '#00F5FF');
        infoWindow.addText('Header buttons: 3', '#00FF88');
        infoWindow.addText('HUD mode: NOWE!', '#00FF88');
        infoWindow.addText('Floating eye: przywraca', '#00FF88');
        
        infoWindow.onClose = () => {
            console.log('Zamykam Info!');
            windowManager.remove(infoWindow);
            taskbar.removeWindowItem(infoWindow);
        };
        
        windowManager.add(infoWindow);
        taskbar.addWindowItem('Info', infoWindow);
        
        // Window 3: Features
        const featuresWindow = new UI.BaseWindow(50, 350, 'Features');
        featuresWindow.width = 400;
        featuresWindow.height = 220;
        featuresWindow.addText('* Close removes from menu', '#00FF88');
        featuresWindow.addText('* Minimize hides + taskbar', '#00FF88');
        featuresWindow.addText('* Eye = HUD mode (no frame)', '#00FF88');
        featuresWindow.addText('* Perfect for 3D overlays!', '#00FF88');
        featuresWindow.addText(' ');
        
        featuresWindow.addButton('Add Window', () => {
            const newWindow = new UI.BaseWindow(
                Math.random() * 400 + 100,
                Math.random() * 200 + 100,
                'Window #' + (windowManager.windows.length + 1)
            );
            newWindow.width = 250;
            newWindow.height = 150;
            newWindow.addText('Nowe okno z buttonami!', '#00FF88');
            newWindow.addText('Kliknij X zeby zamknac', '#00F5FF');
            
            newWindow.onClose = () => {
                console.log('Zamykam nowe okno!');
                windowManager.remove(newWindow);
                taskbar.removeWindowItem(newWindow);
            };
            
            windowManager.add(newWindow);
            taskbar.addWindowItem('Window #' + windowManager.windows.length, newWindow);
        });
        
        featuresWindow.onClose = () => {
            console.log('Zamykam Features!');
            windowManager.remove(featuresWindow);
            taskbar.removeWindowItem(featuresWindow);
        };
        
        windowManager.add(featuresWindow);
        taskbar.addWindowItem('Features', featuresWindow);
        
        const eventRouter = new UI.EventRouter(canvas, null, windowManager, taskbar, null);
        
        console.log('=== UI READY! ===');
        console.log('FUNKCJE:');
        console.log('- X: zamyka okno (usuwa z menu)');
        console.log('- _: minimalizuje (button na taskbar)');
        console.log('- O: HUD mode (floating stats bez ramki)');
        console.log('- Floating eye button: przywraca header');
        console.log('Kliknij Eye zeby zobaczyc HUD mode!');
        
        // ============================================
        //  RENDER LOOP
        // ============================================
        
        function render() {
            ctx.save();
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            windowManager.windows.forEach(w => w.isDirty = true);
            windowManager.draw(ctx, UI.STYLES);
            
            ctx.save();
            taskbar.draw(ctx, UI.STYLES, UI.measureTextCached);
            ctx.restore();
            
            ctx.fillStyle = '#00FF88';
            ctx.font = 'bold 16px Courier New';
            ctx.fillText('FAZA C1 COMPLETE: HUD Mode v2.0!', 20, canvas.height - 70);
            
            ctx.fillStyle = '#666666';
            ctx.font = '12px Courier New';
            ctx.fillText('X=zamknij, _=minimize, O=HUD mode (floating stats, no frame)', 20, canvas.height - 50);
            ctx.fillText('Kliknij Eye button zeby zobaczyc HUD! Floating eye button przywraca.', 20, canvas.height - 30);
            
            ctx.restore();
            
            requestAnimationFrame(render);
        }
        
        render();
        console.log('=== RENDER STARTED ===');
    </script>
</body>
</html>
